WRAPPER FUNCTIONS

Location Based Targeting Checks
===============================

checkPosition(source,targetList,target,verbose)

isSelectedLocation(source,pos,args)



Unit Based Targeting Checks
===========================

checkUnitLocation(center,radius)

checkTarget(source,targetList,target)

isSelectedUnit(source,unit,args)



Item Based Targeting Checks
===========================

checkItemLocation(center,radius)

checkItem(source,targetList,target)

isSelectedItem(source,item,args)



Equation Functions
==================

getValue


ITEM FUNCTIONS

Item Table Functions
====================

makeItemTable(item)
  Purpose: Create a persistant table to track information of a given item
  Calls:   NONE
  Inputs:
           item = Item struct or item id
  Returns: NONE

getItemTable(item)
  Purpose: Collects all information from the game and the items persistant table into an easily accessible lua table
  Calls:   NONE
  Inputs:
           item = Item struct or item id
  Returns: Table of information about the item


Tracking Functions
==================

trackMaterial(item,material,dur,alter)
  Purpose: Tracks material changes to an item
  Calls:   changeMaterial
  Inputs:
           item     = Item struct or item id
           material = MATERIAL_TYPE:MATERIAL_SUBTYPE
           dur      = Length of change in in-game ticks
           alter    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
  Returns: NONE

trackQuality(item,quality,dur,alter)
  Purpose: Tracks quality changes to an item
  Calls:   changeQuality
  Inputs:
           item     = Item struct or item id
           quality  = Quality number (0-7)
           dur      = Length of change in in-game ticks
           alter    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
  Returns: NONE

trackSubtype(item,material,dur,alter)
  Purpose: Tracks subtype changes to an item
  Calls:   changeSubtype
  Inputs:
           item     = Item struct or item id
           subtype  = ITEM_SUBTYPE
           dur      = Length of change in in-game ticks
           alter    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
  Returns: NONE


Changing Functions
==================

changeMaterial(item,material,dur,track)
  Purpose: Change the material an item is made from (temporarily or permanently) and track the change
  Calls:   trackMaterial
  Inputs:
           item     = Item struct or item id
           material = Material string (MATERIAL_TYPE:MATERIAL_SUBTYPE) to change item to
           dur      = Length of change in in-game ticks
           track    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
  Returns: NONE

changeQuality(item,quality,dur,track)
  Purpose: Change the quality of an item (temporarily or permanently) and track the change
  Calls:   trackQuality
  Inputs:
           item    = Item struct or item id
           quality = Quality number (0-7)
           dur     = Length of change in in-game ticks
           track   = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
  Returns: NONE

changeSubtype(item,subtype,dur,track)
  Purpose: Change the subtype of an item (temporarily or permanently) and track the change
  Calls:   trackSubtype
  Inputs:
           item    = Item struct or item id
           subtype = ITEM_SUBTYPE to change item into
           dur     = Length of change in in-game ticks
           track   = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
  Returns: NONE


Attack Functions
================

getAttack(item,attack)
  Purpose: Gets the attack number of an item
  Calls:   NONE
  Inputs:
           item   = Item struct or item id
           attack = ATTACK_TOKEN (e.g. PUNCH), attack verb, or Random
  Returns: Attack ID number


Creation Functions
==================

create(item,material,creatorID,quality,dur)
  Purpose: Creates an item of the given material and quality
  Calls:   NONE
  Inputs:
           item      = ITEM_TYPE:ITEM_SUBTYPE
           material  = MATERIAL_TYPE:MATERIAL_SUBTYPE
           creatorID = Unit ID to use as item creator
           quality   = Quality number of item (0-7)
           dur       = Length of time in in-game ticks for item to exist
  Returns: ID of created item

removal(item)
  Purpose: Destroys an item correctly
  Calls:   NONE
  Inputs:
           item = Item struct or item id to destroy
  Returns: NONE

equip(item,unit,bodyPart,mode)
  Purpose: Equips an item to a unit ignoring normal equipment requirements
  Calls:   NONE
  Inputs:
           item     = Item struct or item id to equip
           unit     = Unit struct or unit id to equip item to
           bodyPart = Body Part id to equip item to
           mode     = Equip mode (e.g. Worn)
  Returns: NONE

unequip(item,unit)
  Purpose: Unequips an item from a unit
  Calls:   NONE
  Inputs:
           item = Item struct or item id to unequip
           unit = Unit struct or unit id to unequip item from
  Returns: NONE


Projectile Functions
====================

makeProjectileFall(item,origin,velocity)
  Purpose: Turn an item into a falling projectile
  Calls:   NONE
  Inputs:
           item     = Item struct or item id
           origin   = { x y z }
           velocity = { x y z } (falling projectiles use a three component velocity)
  Returns: NONE

makeProjectileShoot(item,origin,target,options)
  Purpose: Turn an item into a shooting projectile
  Calls:   NONE
  Inputs:
           item    = Item struct or item id
           origin  = { x y z }
           target  = { x y z }
           options = { velocity=#, accuracy=#, range=#, minimum=#, firer=# } (shooting projectiles use a single component velocity)
  Returns: NONE


Miscellanious Functions
=======================

findItem(search)
  Purpose: Find an item on the map that satisfies the search criteria
  Calls:   NONE
  Inputs:
           search = Search table (e.g. { RANDOM, WEAPON, ITEM_WEAPON_SWORD_SHORT })
  Returns: Table of all items that meet search criteria

MAP FUNCTIONS

Map Changing Functions
======================

changeInorganic(x,y,z,inorganic,dur)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

changeTemperature(x,y,z,temperature,dur)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 



Position Functions
==================

checkBounds(x,y,z)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

checkFree(x,y,z)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

checkSurface(x,y,z)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

getPositions(posType,options)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

getPosition(posType,options)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 



Flow and Liquid Functions
=========================

spawnFlow(edges,offset,flowType,inorganic,density,static)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

spawnLiquid(edges,offset,depth,magma,circle,taper)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

flowSource(n)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

flowSink(n)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

liquidSource(n)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

liquidSink(n)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

getFlow(pos,flowType)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 



Plant Functions
===============

getTree(pos,array)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

getTreePositions(tree)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

getShrub(pos,array)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

removeTree(pos)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

removeShrub(pos)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 



Miscellanious Functions
=======================

findLocation(search)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 



Milo's Tile Mat Functions
=========================

This is taken from Milo Christianson's Rubble Utility and translated to work without that framework
This module contains functions for finding the material of a tile.

There is a function that will find the material of the tile based on it's type (in other words
it will return the material DF is using for that tile), and there are functions that will attempt
to return only a certain class of materials.

Most users will be most interested in the generic "GetTileMat" function, but the other functions
should be useful in certain cases. For example "GetLayerMat" will always return the material of
the stone (or soil) in the current layer, ignoring any veins or other inclusions.

Some tile types/materials have special behavior with the "GetTileMat" function.

* Open space and other "material-less" tiles (such as semi-molten rock or eerie glowing pits) will return nil.
* Ice will return the hard-coded water material ("WATER:NONE").
* Grass is ignored.

The specialized functions will return nil if a material of their type is not possible for a tile.
For example calling "GetVeinMat" for a tile that does not have (and has never had) a mineral vein
will always return nil.

There are two functions for dealing with constructions, one to get the material of the construction
and one that gets the material of the tile the construction was built over.
I am not sure how caved in tiles are handled, but after some quick testing it appears that the
game creates mineral veins for them. I am not 100% sure if these functions will reliably work
with all caved in tiles, but I can confirm that they do in at least some cases...

getTileMat(x,y,z)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 


BUILDING FUNCTIONS

Building Table Functions
========================

makeBuildingTable(building)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

getBuildingTable(building)
  Purpose:
  Calls:
  Inputs:
  Returns:


Tracking Functions
==================

trackSubtype(building,subtype,dur,alter)
  Purpose: 
  Calls:   
  Inputs:
  Returns:


Building Item Functions
=======================

addItem(building,item,dur)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 
 
removeItem(building,item,dur)
  Purpose:
  Calls:
  Inputs:
  Returns:


Building Changing Functions
===========================

changeSubtype(building,subtype,dur,track)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 


Miscellanious Functions
=======================

findBuilding(search)
  Purpose: 
  Calls:   
  Inputs:
  Returns: 

UNIT FUNCTIONS

Unit Table Functions 
====================

makeUnitTable(unit)
  Purpose: Create a persistant table to track information of a given unit
  Calls:   NONE
  Inputs:
           unit = The unit struct or unit ID to make the table for
  Returns: NONE

getUnitTable(unit)
  Purpose: Collects all information from the game and the units persistant table into an easily accessible lua table
  Calls:   NONE
  Inputs:
           unit = The unit struct or unit ID to gather information for
  Returns: Table of information about the unit


Tracking Functions                                
==================

trackCore(unit,strname,kind,change,syndrome,dur,alter,cb_id)
  Purpose: Tracks all changes to a units attributes, resistances, skills, stats, and traits 
  Calls:   trackStart, trackEnd, trackTerminate, changeAttribute, changeResistance, changeSkill, changeStat, changeTrait
  Inputs:
           unit     = The unit struct or unit ID of the unit to track
           strname  = Tracked type (Valid Values: Attribute, Resistance, Skill, Stat, Trait)
           kind     = Tracked subtype (e.g. STRENGTH for a strname of Attribute)
           change   = Amount of change
           syndrome =  SYN_NAME of a syndrome to associate with the change
           dur      = Length of change in in-game ticks
           alter    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           cb_id    = If dur > 0 then the cb_id is needed to properly track the change
  Returns: NONE
  
trackTransformation(unit,race,caste,dur,alter,syndrome,cb_id)
  Purpose: Tracks changes to a units race and caste
  Calls:   changeRace
  Inputs:
           unit     = The unit struct or unit ID of the unit to track
           race     = Race ID the unit turned into
           caste    = Caste ID the unit turned into
           dur      = Length of change in in-game ticks
           alter    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           syndrome = SYN_NAME of a syndrome to associate with the change
           cb_id    = If dur > 0 then the cb_id is needed to properly track the change
  Returns:


Number Changing Functions 
=========================

changeAttribute(unit,attribute,change,dur,track,syndrome)
  Purpose: Change a units attribute (temporarily or permanently) and track the change
  Calls:   trackCore
  Inputs:
           unit      = Unit struct or unit ID
           attribute = ATTRIBUTE_TOKEN of attribute to change
           change    = Amount to change attribute by
           dur       = Length of change in in-game ticks
           track     = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           syndrome  = SYN_NAME of a syndrome to associate with the change
  Returns: NONE
  
changeCounter(unit,counter,change,dur)
  Purpose: Change the "counter" value of a unit (e.g. webbed, dazed, winded, etc...)
  Calls:   NONE
  Inputs:
           unit    = Unit struct or unit ID
           counter = Counter to change, see function for valid values
           change  = Amount to change the counter by
           dur     = Length of change in in-game ticks (most counters decrease or increase naturally)
  Returns: NONE
  
changeResistance(unit,resistance,change,dur,track,syndrome)
  Purpose: Change a units resistance (temporarily or permanently) and track the change
  Calls:   trackCore
  Inputs:
           unit       = Unit struct or unit ID
           resistance = RESISTANCE_TOKEN of resistance to change
           change     = Amount to change resistance by
           dur        = Length of change in in-game ticks
           track      = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           syndrome   = SYN_NAME of a syndrome to associate with the change
  Returns: NONE
  
changeSkill(unit,skill,change,dur,track,syndrome)
  Purpose: Change a units skill levle (temporarily or permanently) and track the change
  Calls:   trackCore
  Inputs:
           unit     = Unit struct or unit ID
           skill    = SKILL_TOKEN of skill to change
           change   = Amount to change skill level by
           dur      = Length of change in in-game ticks
           track    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           syndrome = SYN_NAME of a syndrome to associate with the change
  Returns: NONE
  
changeStat(unit,stat,change,dur,track,syndrome)
  Purpose: Change a units stat (temporarily or permanently) and track the change
  Calls:   trackCore
  Inputs:
           unit     = Unit struct or unit ID
           stat     = STAT_TOKEN of stat to change
           change   = Amount to change stat by
           dur      = Length of change in in-game ticks
           track    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           syndrome = SYN_NAME of a syndrome to associate with the change
  Returns: NONE
  
changeTrait(unit,trait,change,dur,track,syndrome)
  Purpose: Change a units trait (temporarily or permanently) and track the change
  Calls:   trackCore
  Inputs:
           unit     = Unit struct or unit ID
           trait    = TRAIT_TOKEN of trait to change
           change   = Amount to change trait by
           dur      = Length of change in in-game ticks
           track    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           syndrome = SYN_NAME of a syndrome to associate with the change
  Returns: NONE


Action Changing Functions
=========================

changeAction(unit,action_type,timer)
  Purpose: Changes the timer on a units action, allowing them to act more often
  Calls:   NONE
  Inputs:
           unit        = Unit struct or unit ID
           action_type = Action type (Valid Values: Move, Attack, Block, Dodge, etc...)
           timer       = Number to set timer on action to (Special Values: clear, clearAll)
  Returns: NONE
  
changeInteraction(unit,interaction_id,timer,types)
  Purpose: Changes the delay timer on a units interaction, allowing them to occur more or less frequently
  Calls:   NONE
  Inputs:
           unit           = Unit struct or unit ID
           interaction_id = Interaction ID number
           timer          = Number to set timer on action to (Special Values: clear, clearAll)
           types          = Interaction Type (Valid Values: Innate, Learned, Both)
  Returns: NONE

 

Body Changing Functions
=======================

changeBody(unit,part,changeType,change,dur)
  Purpose: Changes a units body and body parts size or temperature
  Calls:   NONE
  Inputs:
           unit       = Unit struct or unit ID
           part       = Body part ID
           changeType = Type of change (Valid Values: Temperature, Size, Area, Length)
           change     = Amount of change (Special Value: fire - sets body part on fire)
           dur        = Length of change in in-game ticks
  Returns: NONE
  
changeLife()
  Purpose:
  Calls:
  Inputs:
  Returns: NONE
  
changeRace(unit,race,caste,dur,track,syndrome)
  Purpose:
  Calls:   trackTransformation
  Inputs:
           unit     = Unit struct or unit ID
           race     = Race ID to transform into
           caste    = Caste ID to transform into
           dur      = Length of transformation in in-game ticks
           track    = Type of tracking (Valid Values: track, end, terminate, terminateClass, terminated)
           syndrome = SYN_NAME of a syndrome to associate with the transformation
  Returns: NONE
  
changeWound()
  Purpose:
  Calls:
  Inputs:
  Returns: NONE


Syndrome Changing Functions
===========================

changeSyndrome(unit,syndromes,change,dur)
  Purpose: Make changes to a units syndromes by adding, erasing, terminating, or altering their duration
  Calls:   modtools/add-syndrome | trackCore | checkSyndrome
  Inputs:
           unit      = Unit struct or unit ID
           syndromes = SYN_NAME of syndromes to change (or SYN_CLASS)
           change    = Type of change (Valid Values: add, erase, eraseClass, terminate, terminateClass, alterDuration, alterDurationClass)
           dur       = Length syndrome will last in in-game ticks (or amount of ticks to change syndrome length by)
  Returns: NONE


Boolean Functions
=================

checkClass(unit,class)
  Purpose: Checks if a unit has the given class, either as a CREATURE_CLASS or SYNDROME_CLASS
  Calls:   checkClassCreature | checkClassSyndrome
  Inputs:
           unit  = Unit struct or unit ID
           class = CREATURE_CLASS or SYNDROME_CLASS
  Returns: True/False
  
checkCreatureRace(unit,creature)
  Purpose: Checks if a unit belongs to a given RACE:CASTE combo
  Calls:   NONE
  Inputs:
           unit     = Unit struct or unit ID
           creature = RACE:CASTE (or RACE:ANY)
  Returns: True/False
  
checkCreatureSyndrome(unit,syndrome)
  Purpose: Checks if a unit has a syndrome with the given SYN_NAME
  Calls:   NONE
  Inputs:
           unit     = Unit struct or unit ID
           syndrome = SYN_NAME
  Returns: True/False
  
checkCreatureToken(unit,token)
  Purpose: Checks if the unit has the given token
  Calls:   NONE
  Inputs:
           unit  = Unit struct or unit ID
           token = TOKEN (e.g. MEGABEAST, GRAZER, etc...)
  Returns: True/False
  
checkDistance(unit,location,distance)
  Purpose: Checks if the unit is within a specific distance of given location
  Calls:   NONE
  Inputs:
           unit     = Unit struct or unit ID
           location = { x, y, z }
           distance = # or { x, y, z }
  Returns: True/False


Body Part Functions
===================

getBodyParts(unit,partType,partSubType)
  Purpose: Get a table of body part ids that match the given Type and SubType search
  Calls:   getBodyCategory | getBodyToken | getBodyFlag | getBodyConnectedParts | getBodyPartGlobalLayers
  Inputs:
           unit        = Unit struct or unit ID
           partType    = Part search type (Valid Values: Category, Token, Flag, Connected, Layers)
           partSubType = Part search subtype, depends on the partType
  Returns: Table of Body Part IDs
  
getBodyRandom(unit)
  Purpose: Get the body part ID of a random body part weighted by their size
  Calls:   NONE
  Inputs:
           unit = Unit struct or unit ID
  Returns: Body Part ID


Corpse Functions
================

getBodyCorpseParts(unit)
  Purpose: Get a list of all the units corpse part IDs and corpse ID
  Calls:   NONE
  Inputs:
           unit = Unit struct or unit ID
  Returns: Table of corpse part IDs and corpse ID
  
getItemCorpse(caste)
  Purpose: Get the item corpse the creature creates when they die
  Calls:   NONE
  Inputs:
           unit = Unit struct or unit ID
  Returns: String of item corpse item and mat or 'Corpse'  


Inventory Functions
===================

getInventory(unit,inventoryType,inventorySubType)
  Purpose: Get the item ids of a unit inventory based on given criteria
  Calls:   getInventoryType | getInventoryBodyPart | getInventoryMode
  Inputs:
           unit             = Unit struct or unit ID
           inventoryType    = Inventory search type (Valid Values: ItemType, BodyPart, Mode)
           inventorySubType = Inventory search subtype, depends on inventory search type
  Returns: Table of item IDs


Miscellanious Get Functions
===========================

getAttack(unit,attack_type)
  Purpose: Get the attack ID and associated body part ID of a random or specific attack
  Calls:   NONE
  Inputs:
           unit        = Unit struct or unit ID
           attack_type = ATTACK_TOKEN (e.g. PUNCH) or Random
  Returns: Attack ID, Body Part ID of attack
  
getEmotion(unit,emotion,thought)
  Purpose: Get a list of all the emotions that satisfy the given emotion/thought combination
  Calls:
  Inputs:
           unit    = Unit struct or unit ID
           emotion = EMOTION_TOKEN
           thought = THOUGHT_TOKEN
  Returns: Table of unit emotion IDs
  
getSyndrome(unit,class,what)
  Purpose: Get the syndrome names and ids of all syndromes that match a given SYN_NAME or SYN_CLASS
  Calls:   NONE
  Inputs:
           unit  = Unit struct or unit ID
           class = SYN_NAME or SYN_CLASS
           what  = (Valid Values: name, class)
  Returns: Table of SYN_NAME, Table of syndrome IDs, Table of units syndrome IDs
  
getCounter(unit,counter)
  Purpose: Get the value of a units specific counter
  Calls:   NONE
  Inputs:
           unit    = Unit struct or unit ID
           counter = Counter token (e.g. webbed)
  Returns: Value of counter


Miscellanious Functions
=======================

makeProjectile(unit,velocity)
  Purpose: Turn a unit into a projectile
  Calls:   NONE
  Inputs:
           unit     = Unit struct or unit ID
           velocity = { x, y, z }
  Returns: NONE
  
findUnit(search)
  Purpose: Find a unit on the map that satisfies the search criteria
  Calls:   NONE
  Inputs:
           search = Search table (e.g. { RANDOM, PROFESSION, CARPENTER })
  Returns: Table of all units that meet search criteria


Unit Creation Functions 
=======================

create()
  Purpose:
  Calls:
  Inputs:
  Returns:
  
createClass(unit,classes)
  Purpose:
  Calls:
  Inputs:
  Returns:
  
createEquipment(unit,equip)
  Purpose:
  Calls:
  Inputs:
  Returns:
  
createSkills(unit,skills)
  Purpose:
  Calls:
  Inputs:
  Returns:

