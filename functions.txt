#######################################
######### ATTACK FUNCTIONS ############
#######################################
    addAttack(unit,defenderID,attackBodyPartID,targetBodyPartID,attackItemID,attackID,accuracy,velocity,delay)
      Purpose: Add an attack action to the unit
      Calls: None
      Inputs:
            unit:                   Attacker unit ID or unit struct
            defenderID:             Defender unit ID
            attackBodyPartID:       Attacker's attacking body part ID (if using a body part attack)
            targetBodyPartID:       Defender's targeted body part ID
            attackItemID:           Attacker's attacking item ID (if using an item attack)
            attackID:               Attack ID number (found in unit.body.body_plan.attacks or item.subtype.attacks)
            accuracy:               Percent hit chance of attack
            velocity:               Velocity of attack
            delay:                  Time (in ticks) until attack is executed
      Returns: NA
    
    getAttack(unit,category,type)
      Purpose: Get attack details of equipped weapons and/or body parts
      Calls: getAttackItem | getAttackUnit | unit.getInventoryType | unit.getAttack | item.getAttack 
      Inputs:
            unit:                   Unit ID or unit struct
            category:               Category of attack (Valid values: Equipped, Created, or BodyPart)
            type:                   RAW Token of attack (e.g. PUNCH) (Special Value: Random)
      Returns: Table - { material momentum contact penetration sharpness item body_part }
    
    getDefense(unit,category,type)
      Purpose: Get layer, tissue, and material information for a given body part
      Calls: checkCoverage | unit.getBodyRandom | unit.getBodyCategory | unit.getBodyToken | unit.getBodyType
      Inputs:
            unit:                   Unit ID or unit struct
            category:               Category of body part to check for (Valid values: Random, Category, Token, or Type)
            type:                   RAW token for above category (e.g. EYES, REYE, and SIGHT would all check eyes)
      Returns: Table - { layers tissues items materials body_part }
    
    computeAttackValues(attacker,defender,attackCategory,attackType,defenseCategory,defenseType)
      Purpose:
      Calls: computeAttackValuesItems, computeAttackValuesLayers
      Inputs:
            attacker:               Attacking unit ID or unit struct
            defender:               Defending unit ID or unit struct
            attackCategory:         Category of attack (see getAttack for more information)
            attackType:             Type of attack (see getAttack for more information)
            defenseCategory:        Category of defense (see getDefense for more information)
            defenseType:            Type of defense (see getDefense for more information)
      Return: Numbers - momentum_deduction1, momentum_deduction2

#######################################
######## BUILDING FUNCTIONS ###########
#######################################
    addItem(building,item,duration)
      Purpose: Adds an item to a buildings item list
      Calls: persist-delay.environmentDelay
      Inputs:
            building:               Building ID or building struct
            item:                   Item ID or item struct
            duration:               Time (in ticks) for the item to remain in the building
      Returns: NA
    
    removeItem(building,item,duration)
      Purpose: Removes an item from a buildings item list
      Calls: persist-delay.environmentDelay
      Inputs:
            building:               Building ID or building struct
            item:                   Item ID or item struct
            duration:               Time (in ticks) for the item to remain outside of building
      Returns: NA
    
    changeSubtype(building,subtype,duration)
      Purpose: Changes the subtype of a building
      Calls: persist-delay.environmentDelay
      Inputs:
            building:               Building ID or building struct
            subtype:                RAW Token of custom building
            duration:               Time (in ticks) for the change to last
      Returns: Boolean - Did the building successfully change?
    
    findBuilding(searchTable)
      Purpose: Finds a building that satisfies certain criteria
      Calls: misc.permute
      Inputs:
            searchTable:            Table of strings to search for a building on the map (NEED TO ADD MORE INFORMATION)
      Returns: Table - { target[s] )

#######################################
######### ENTITY FUNCTIONS ############
#######################################
    changeResources(entity,group,category,mainToken,subToken,direction,verbose)
      Purpose: Add or remove a given resource from an entity
      Calls: changeCreature | changeInorganic | changeItem | changeMisc | changeOrganic | changeRefuse | changeProduct | changeSkill | changeEthic | changeValue
      Inputs:
            entity:                 Entity ID or entity struct
            group:                  Group of resources to change (Valid Values: CREATURE, INORGANIC, ITEM, MISC, ORGANIC, REFUSE, PRODUCT, SKILLS, ETHICS, or VALUES)
            category:               Category of group to change (see above functions for valid values)
            mainToken:              Depends on the group and category
            subToken:               Depends on the group and category
            direction:              add or remove
            verbose:                Boolean, whether to print extra debugging information
      Returns: NA

#######################################
########## ITEM FUNCTIONS #############
#######################################
    changeMaterial(item,materialTokens,duration,track)
      Purpose: Change the material an item is made of
      Calls: trackMaterial | tables.makeItemTable | persist-delay.environmentDelay
      Inputs:
            item:                   Item ID or item struct
            materialTokens:         RAW Token material (e.g. INORGANIC:IRON, CREATURE_MAT:DWARF:BONE, etc..)
            duration:               Time (in ticks) for change to last
            track:                  How to track the material change (Valid Values: track, end, or nil)
      Returns: NA
    
    changeQuality(item,quality,duration,track)
      Purpose: Change the quality of an item
      Calls: trackQuality | tables.makeItemTable | persist-delay.environmentDelay
      Inputs:
            item:                   Item ID or item struct
            quality:                Number of quality to set item to
            duration:               Time (in ticks) for change to last
            track:                  How to track the quality change (Valid Values: track, end, or nil)
      Returns: NA
    
    changeSubtype(item,subtype,duration,track)
      Purpose: Change the subtype of an item
      Calls: trackSubtype | tables.makeItemTable | persist-delay.environmentDelay
      Inputs:
            item:                   Item ID or item struct
            subtype:                RAW Token of item subtype
            duration:               Time (in ticks) for change to last
            track:                  How to track the subtype change (Valid Values: track, end, or nil)
      Returns: NA
    
    create(item,material,creatorID,quality,duration)
      Purpose: Creates an item of the given material for a set duration
      Calls: removal | persist-delay.environmentDelay
      Inputs:
            item:                   RAW Token item (e.g. WEAPON:ITEM_WEAPON_SWORD_SHORT)
            material:               RAW Token material (e.g. INORGANIC:IRON, CREATURE_MAT:DWARF:BONE, etc..)
            creatorID:              Unit ID
            quality:                Quality number
            duration:               Time (in ticks) for item to last
      Returns: NA
    
    equip(item,unit,bodyPart,mode)
      Purpose: Move an item from the ground into a unit's inventory
      Calls: None
      Inputs:
            item:                   Item ID or item struct
            unit:                   Unit ID or unit struct
            bodyPart:               Body part ID
            mode:                   Inventory mode number
      Returns: NA
    
    unequip(item,unit)
      Purpose: Move an item from the unit's inventory to the ground
      Calls: None
      Inputs:
            item:                   Item ID or item struct
            unit:                   Unit ID or unit struct
      Returns: NA
    
    getAttack(item,attackToken)
      Purpose: Find the given attack of an item
      Calls: None
      Inputs:
            item:                   Item ID or item struct
            attackToken:            RAW Token of an attack (e.g. PUNCH) (Special Value: Random)
      Returns: Number - AttackID
    
    makeProjectileFall(item,origin,velocity)
      Purpose: Turn an item into a falling projectile
      Calls: None
      Inputs:
            item:                   Item ID or item struct
            origin:                 Table of x,y,z coordinates
            velocity:               Table of x,y,z velocities
      Returns: NA
    
    makeProjectileShot(item,origin,target,options)
      Purpose: Turn an item into a shot projectile
      Calls: None
      Inputs:
            item:                   Item ID or item struct
            origin:                 Table of x,y,z coordinates
            target:                 Table of x,y,z coordinates
            options:                Table of special values { velocity accuracy range minimumDistance firer }
      Returns: NA
    
    findItem(searchTable)
      Purpose: Find an item given a specific search string
      Calls: misc.permute
      Inputs:
            searchTable:            Table of strings to search for an item on the map (NEED TO ADD MORE INFORMATION)
      Returns: Table - { item[s] }
 
#######################################
########### MAP FUNCTIONS #############
#######################################
    changeInorganic(x,y,z,inorganicToken,duration)
      Purpose: Changes the inorganic at specified position
      Calls: persist-delay.environmentDelay
      Inputs:
            x:                      X Location or Table of x,y,z coordinates
            y:                      Y location if x isn't a table
            z:                      Z location if x isn't a table
            inorganicToken:         RAW Token of inorganic
            duration:               Time (in ticks) for the change to last
      Returns: Boolean - Was the change successful?
    
    changeTemperature(x,y,z,temperature,duration)
      Purpose: Changes the temperature at specified position (doesn't really work well since the game constantly reupdates temperatures)
      Calls: persist-delay.environmentDelay
      Inputs:
            x:                      X Location or Table of x,y,z coordinates
            y:                      Y location if x isn't a table
            z:                      Z location if x isn't a table
            temperature:            Number to set temperature to
            duration:               Time (in ticks) for the change to last
      Returns: Boolean - Was the change successful?
    
    getPosition(Type,options)
      Purpose: Returns a single position { x y z } depending on the given type and options
      Calls: getPositionCenter | getPositionEdge | getPositionRandom | getPositionCavern | getPositionSurface | getPositionSky
             getPositionUnderground | getPositionLocationRandom | getPositionUnitRandom | checkBounds | checkFree | checkSurface
      Inputs:
            Type:                   Type of position to return (Valid Values: Center, Edge, Random, Cavern, Surface, SurfaceFree, Sky, Underground, LocationRandom, UnitRandom)
            options:                An array of optional arguments depending on the Type
                    unit:           (If using UnitRandom) The unit struct or unitID to center the position on
                    location:       (If using Surface, Sky, Underground, or LocationRandom) The location { x y z } to center the position on
                    radius:         (If using Center, LocationRandom, or UnitRandom) The radius ( x y z ) around the central location
                    caveNumber:     (If using Cavern) The cave number to search for a position in
      Returns: Table { x, y, z}
    
    getPositions(Type,options)
      Purpose: Returns a table of positions { { x y z } } depending on the given type and options
      Calls: getEdgesPositions | getFillPositions | getPlanPositions
      Inputs:
            Type:                   Type of positions to return (Valid Values: Edges, Fill, Plan)
            Options:                An array of optional arguments depending on the Type
                    target:         (If using Edges, Fill, or Plan) The position { x y z } to center on
                    radius:         (If using Edges or Fill) The radius { x y z } around the center to include
                    origin:         (If using Plan) The position { x y z } to reference as the origin for rotation
                    file:           (If using Plan) The file to read for the positional information
      Returns: Table, Number - { position[s] }, # of positions
    
    getFlow(position,flowType)
      Purpose: Get all flows of a specific type and the given position
      Calls: None
      Inputs:
             Position:              Table of { x y z } coordinate
             FlowType:              (Optional) If present it will restrict the flow check to that specific flow type
      Returns: Table - { flow[s] }
    
    getTileFeature(type,position,array)
      Purpose: Get the table entry of the specified feature type at a given positions
      Calls: getTree | getShrub
      Inputs:
             Type:                  Type of feature/object to look for (Valid Values: Tree or Shrub)
             Position:              Table of { x y z } coordinate
             Array:                 (Optional) The DFHack array to check against (e.g. df.global.world.plants.all)
      Returns: Number, Struct - # of Struct Entry, DFHack Struct
    
    getTileMat(x,y,z)               **Taken from Milo Christianson's Rubble Utility and translated to work without that framework
      Purpose: Get the material string that cooresponds with that is seen in game
      Calls: getTileTypeMat | getLayerMat | getLavaStone | getVeinMat | getConstructionMat | getConstructOriginalTileMat | getTreeMat
             getShrubMat | getFeatureMat
      Inputs:
             x:                     Either a table of { x y z } coordinates or the x coordinate
             y:                     The y coordinate if x is not a table
             z:                     The z coordinate if x is not a table
      Returns: String - RAW material token
    
    spawnFlow(edges,offset,flowType,inorganicToken,density,static)
      Purpose: Spawns a flow with given characteristics
      Calls: None
      Inputs:
            edges:                  Table of x,y,zmin and x,y,zmax
            offset:                 Table of x,y,z distances
            flowType:               Flow Token (Valid Values: MIASMA, STEAM, MIST, MATERIALDUST, MAGMAMIST, SMOKE, DRAGONFIRE, FIRE, WEB, MATERIALGAS, MATERIALVAPOR, OCEANWAVE, SEAFOAM, or ITEMCLOUD)
            inorganicToken:         RAW inorganic token
            density:                Number of flow density
            static:                 Boolean for whether the flow can move or not
      Returns: NA
    
    spawnLiquid(edges,offset,depth,magma,circle,taper)
      Purpose: Spawns water or magma with given characteristics
      Calls: None
      Inputs:
            edges:                  Table of x,y,zmin and x,y,zmax
            offset:                 Table of x,y,z distances
            depth:                  Number of liquid depth
            magma:                  Boolean for whether magma or not (i.e. water)
            circle:                 Boolean for if the liquid should be spawned in a circle
            taper:                  Boolean for if the liquid should have a maximum depth at the center and taper off
      Returns: NA
    
    findLocation(searchTable)
      Purpose: Find a location that satisfies a specific search criteria
      Calls: misc.permute
      Inputs:
            searchTable:            Table of strings to search for a location on the map (NEED TO ADD MORE INFORMATION)
      Returns: Table - { location[s] }

#######################################
########## UNIT FUNCTIONS #############
#######################################
	changeAttribute(unit,attribute,change,duration,track,syndrome)

	changeCounter(unit,counter,change,duration)

	changeResistance(unit,resistance,change,duration,track,syndrome)

	changeSkill(unit,skill,change,duration,track,syndrome)

	changeStat(unit,stat,change,duration,track,syndrome)

	changeTrait(unit,trait,change,duration,track,syndrome)

	changeBody(unit,part,changeType,change,duration)

	changeLife(unit,corpsePart,change,reference,regrow,syndrome,duration)

	changeWound(unit,bodyPartID,globalLayerID,regrow)

	changeAction(unit,actionType,timer)

	changeInteraction(unit,interactionID,timer,types)

	changeEmotion(unit,thought,subthought,emotion,strength,severity,task,number,duration,syndrome)

	changeFlag(unit,flag,clear)

	changeSide(unit,side,sideType,duration,track,syndrome)

	changeSyndrome(unit,syndromes,change,duration)

	transform(unit,race,caste,duration,track,syndrome)

	move(unit,location)

	removal(unit,removeType)

	checkClass(unit,class)

	checkClassCreature(unit,class)

	checkClassSyndrome(unit,class)

	checkCreatureRace(unit,creature)

	checkCreatureSyndrome(unit,syndrome)

	checkCreatureToken(unit,token)

	checkDistance(unit,location,distance)

	getUnit(unit,category,type,initialize)

	getAttack(unit,attackType)

	getBodyRandom(unit)

	getBodyCategory(unit,category)

	getBodyToken(token)

	getBodyFlag(flag)

	getBodyConnectedParts(unit,bodyPartID)

	getBodyPartGlobalLayers(unit,bodyPartID)

	getBodyCorpseParts(unit)

	getEmotion(unit,emotion,thought)

	getSyndrome(unit,class,what)

	getInventoryType(unit,itemType)

	getInventoryBodyPart(unit,bodyPartID)

	getInventoryMode(unit,mode)

	getCounter(unit,counter)

	getItemCorpse(caste)

	makeProjectile(unit,velocity)
